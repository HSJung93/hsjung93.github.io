---
title: Kubernetes Korea Group 기술 세미나 후기
date: 2023-04-06 10:02:00 +0900
categories: [SlipBox, Meetup]
tags: [Kubernetes, Seminar]
---

### Everything on K8s
- 모든 것을 쿠버네티스에 올리고 있다.

1. 오퍼레이터가 수요가 많아지고 있다.
- 쿠버네티스를 만든 go 언어로 오퍼레이터를 만드는 것이 편리하다. 
- 오퍼레이터 패턴에는 5단계가 존재
- 헬름은 설치(1단계), 업그레이드(2단계) 까지만
- 언서블은 라이프 사이클(3), 메트릭(4) 까지도.

2. 클라우드 리소스를 만드는 방법은 여러가지다
- 예를 들어 S3 만드는 방식은 다양
  - console, aws cli
- 클라우드 리소스도 메니페스트로 선언적으로 만들고 싶은 수요가 생긴다. 
- 계정 정보 + 리소스 + yaml 파일로 만들 수 있다. 

3. 클러스터 API 프로젝트
- 클러스터 또한 선언적인 방식으로 만들고자 하는 프로젝트. 

4. 클러스터 in 클러스터
- 클러스터 안에 가상 클러스터를 띄우기도 한다. 

5. VM in 클러스터
- 쿠버네티스 리소스 관리가 좋아서
- 쿠버네티스 위에 VM을 띄우려는 시도도 있다. 엔비디아 

6. 서버리스
- 쿠버네티스 위에서 서버리스 플랫폼을 만들어주는 솔루션도 등장.
- 클라우드 서비스사들 사이에서 서버리스 만이라도 하려는 VMware

7. CI
- 스피내커, 앤서블, 젠킨스
- 쿠버네티스 위에서 CI 툴이 아직은 클라우드 네이티브 하지 않다. 

7. CD
- argoCD 가 표준. 

8. Workflows
- 아파치 airflow도 operator 패턴을 사용해서 k8s 위에서 사용할 수 있도록 구현 중
- argo workflow와 kuber flow(머신 러닝에 특화) 존재.

9. DB
- k8s에 올려도 되는지 위험하게 느껴진다. Data on Kubernetes 커뮤니티. 
- 매년 리포트를 내는데, 실제 DB를 쿠버네티스에 올려서 사용하는 회사가 많다고 한다. 
- Vitess slack 사례 들. 재작년에 99% vitess를 사용해서 db를 k8s에 올렸다. 
- 유튜브와 깃헙도
- 2020 mysql on k8s kf kakao
- DB 운영 관리 작업은 오퍼레이터 패턴으로 자동화
- 트래픽 증가시 스케일 인아웃
- 네트워크 성능, 스토리지 I/O 성능에서 문제가 없다.
- 데이터베이스 인프라를 코드로 쉽게 배포
- 리소스를 효율적으로 사용.

10. Security
- Kyverno가 뜨고 있다. 

### K8s 기반의 앱 배포 시스템 만들기
- 쿠버네티스와 스프링을 모두 아는 사람이 적다.

- 서비스 실행 = 어플리케이션 실행 = 프로세스 = 바이너리 + cpu + memory
- 바이너리 파일이 이미지, 컨테이너는 프로세스다. 자원을 분배하고 컨테이너 격리할 수 있다. 리눅스 커널에 들어가 있는 기술.
- os 없이 격리된 프로세스가 컨테이너. 
- 컨테이너가 생성되면 나만 read-write할 수 있는 레이어가 생긴다. 이미지는 read-only.

- 멀티 호스트 x 멀티 컨테이너 기술이 필요하게 되었다. 
- 스케줄링, 배치, 실행, 삭제, 재실행, 네트워크 통신, 스케일 아웃, 스토리지
- etcd에 저장되고 etcd만 api로 shed와 controller가 통신한다. 직접 pod로 하지 않는다. 

- pod = image에 대응한다.
  - 여러 컨테이너들이 뜬다.  

- kube api = control plane에 yaml 보낸다. etcd에 저장
- 컨테이너 이미지만 레지스트리에 있으면 k8s가 declative하게 해준다.

- nodeSelector로 노드를 정한다. label을 이용한다.
- nodeAffinity, nodeAntiAffinity: pod 띄우는데, 노드 어피니티는 노드 셀렉터와 비슷하게 띄우는데, 도중이면 띄우지 말라는 등 세부 조건
- podSelector도 있고 같이 뜨면 안되는 것에 label을 사용할 때 필요

- pod - 정상상태 점검
  - 행이 걸린 것을 아는 방법? 찔러본다? 찔러보도록 한다? 로그를 보고 있는다? 
  - kubelet: 노드에 떠있는 k8s 컴포넌트 가 찌른다.
  - livenessProbe: httpGet: path: port: seconds 옵션 등
  - 라이브니스: 도는 중, 레디니스: 준비할 때, 
  - 매번 요청 보내면 너무 많아. startup probe는 최초 기동시에 오래 걸리는 것도 liveness를 대기하도록 해서 가능.

- controller
  - 리소스 별로 다 뜨고 리소스를 파악. 
  - pod가 아니라 deployment 를 본다.
  - reconciliation 한다. 계속 돌면서 yaml을 파악하고 계속 확인한다. 

- replicaSet
  - pod 개수 맞추기

- deployment
  - 히스토리 관리: 이전 버전으로 undo
  - 스케줄링을 한다. (podAntiAffinity) 
  - 같은 노드에 뜨지 않도록 application 배포자 입장에서

- configMap에 
  - 노드에 app.config를 두고, 노드 안의 pod에서 가져간다.
  - application.properties: 이미지로 두면 일반적으로 안좋다. 좋은 점은 다 귀찮아 이미지만 관리 가능.
  - configMap에 두고 경로 지정 안하고 베이직으로 두면서 배포

- storage
  - node 죽어도 데이터 유지. storage 사이 드라이버가 pvc

- 서비스/ 엔드포인트
  - pod는 ip가 네임스페이스 안에서만 쓰고 매번 새로 생성
  - 변하지 않는 pod 접근 아이피, 그런데 도메인 그것이 서비스다. 
  - pod를 호출하기 위한 도메인 시스템
  - 내부 포트
  - 로드 밸랜서 -> 클라우드 컨트롤러 맵, 프로바이더 AWS 등등이 pod를 인식하는 컨트롤러가 있다. 알아서 로드밸런서 만들고 pod에 연결
  - 인그레스 컨트롤러는 pod 안에 있다. 다른 노드에는 없고 

- helm chart는 deploy, pvc, svc 한번에
- rollout으로 블루 그린
- helm chart에는 NotAffinity

- 자바는 nyu os외에 힙 메모리 외에 영역에서 쓰는 것이 있기 때문에, oom kill로 파드가 리셋 가능. 적절하게 좀 더 리밋을 주던가 안 주던가.